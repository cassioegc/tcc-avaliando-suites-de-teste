/*
 * This file was automatically generated by EvoSuite
 * Sun Apr 04 04:32:24 GMT 2021
 */

package com.graphhopper.routing;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.carrotsearch.hppc.IntObjectMap;
import com.graphhopper.routing.AStar;
import com.graphhopper.routing.Dijkstra;
import com.graphhopper.routing.DijkstraOneToMany;
import com.graphhopper.routing.Path;
import com.graphhopper.routing.SPTEntry;
import com.graphhopper.routing.util.TraversalMode;
import com.graphhopper.routing.weighting.WeightApproximator;
import com.graphhopper.routing.weighting.Weighting;
import com.graphhopper.storage.Graph;
import com.graphhopper.storage.NodeAccess;
import com.graphhopper.util.EdgeExplorer;
import com.graphhopper.util.EdgeIteratorState;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class AbstractRoutingAlgorithm_ESTest extends AbstractRoutingAlgorithm_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0, 0, 0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstraOneToMany0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      
      DijkstraOneToMany dijkstraOneToMany1 = dijkstraOneToMany0.clear();
      assertNotNull(dijkstraOneToMany1);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      Graph graph1 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph1).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null, (NodeAccess) null, (NodeAccess) null).when(graph1).getNodeAccess();
      doReturn(0).when(graph1).getNodes();
      Weighting weighting1 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting1).hasTurnCosts();
      TraversalMode traversalMode1 = TraversalMode.NODE_BASED;
      AStar aStar0 = new AStar(graph1, weighting1, traversalMode1);
      assertNotNull(aStar0);
      assertEquals(0, aStar0.getVisitedNodes());
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      
      String string0 = aStar0.getName();
      assertNotNull(string0);
      assertEquals("astar|beeline", string0);
      assertEquals(0, aStar0.getVisitedNodes());
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      assertNotSame(traversalMode1, traversalMode0);
      
      aStar0.setMaxVisitedNodes((-2123));
      assertEquals(0, aStar0.getVisitedNodes());
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      assertNotSame(traversalMode1, traversalMode0);
      
      AStar aStar1 = aStar0.setApproximation((WeightApproximator) null);
      assertNotNull(aStar1);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      assertNotSame(traversalMode1, traversalMode0);
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      
      Path path0 = aStar1.extractPath();
      assertNotNull(path0);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertEquals(0L, path0.getTime());
      assertEquals(1.7976931348623157E308, path0.getWeight(), 0.01);
      assertEquals(0, path0.getEdgeCount());
      assertEquals((-1), path0.getEndNode());
      assertEquals("", path0.getDebugInfo());
      assertFalse(path0.isFound());
      assertEquals(0.0, path0.getDistance(), 0.01);
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      assertNotSame(traversalMode1, traversalMode0);
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      
      Path path1 = aStar1.createEmptyPath();
      assertNotNull(path1);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertEquals(0, path1.getEdgeCount());
      assertEquals(0L, path1.getTime());
      assertFalse(path1.isFound());
      assertEquals((-1), path1.getEndNode());
      assertEquals(0.0, path1.getDistance(), 0.01);
      assertEquals("", path1.getDebugInfo());
      assertEquals(1.7976931348623157E308, path1.getWeight(), 0.01);
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      assertFalse(path1.equals((Object)path0));
      assertNotSame(traversalMode1, traversalMode0);
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      assertNotSame(path1, path0);
      
      Path path2 = aStar1.createEmptyPath();
      assertNotNull(path2);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertEquals(0.0, path2.getDistance(), 0.01);
      assertEquals(0, path2.getEdgeCount());
      assertEquals("", path2.getDebugInfo());
      assertEquals(1.7976931348623157E308, path2.getWeight(), 0.01);
      assertEquals((-1), path2.getEndNode());
      assertEquals(0L, path2.getTime());
      assertFalse(path2.isFound());
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      assertFalse(path2.equals((Object)path1));
      assertFalse(path2.equals((Object)path0));
      assertNotSame(traversalMode1, traversalMode0);
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      assertNotSame(path2, path1);
      assertNotSame(path2, path0);
      
      // Undeclared exception!
      try { 
        aStar1.finished();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.graphhopper.routing.AStar", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      EdgeExplorer edgeExplorer0 = mock(EdgeExplorer.class, new ViolatedAssumptionAnswer());
      NodeAccess nodeAccess0 = mock(NodeAccess.class, new ViolatedAssumptionAnswer());
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn(edgeExplorer0).when(graph0).createEdgeExplorer();
      doReturn(nodeAccess0).when(graph0).getNodeAccess();
      doReturn(1896, 29, 29).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstraOneToMany0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      
      DijkstraOneToMany dijkstraOneToMany1 = dijkstraOneToMany0.clear();
      assertNotNull(dijkstraOneToMany1);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      int int0 = dijkstraOneToMany1.findEndNode(1, 1);
      assertEquals(1, int0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      EdgeIteratorState edgeIteratorState0 = mock(EdgeIteratorState.class, new ViolatedAssumptionAnswer());
      doReturn(29).when(edgeIteratorState0).getEdge();
      boolean boolean0 = dijkstraOneToMany1.accept(edgeIteratorState0, 0);
      assertTrue(boolean0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      double double0 = dijkstraOneToMany1.getWeight(16);
      assertEquals(1.7976931348623157E308, double0, 0.01);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      Graph graph1 = null;
      Weighting weighting1 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting1).hasTurnCosts();
      TraversalMode traversalMode1 = TraversalMode.EDGE_BASED;
      AStar aStar0 = null;
      try {
        aStar0 = new AStar((Graph) null, weighting1, traversalMode1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.graphhopper.routing.AbstractRoutingAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      AStar aStar0 = new AStar(graph0, weighting0, traversalMode0);
      assertNotNull(aStar0);
      assertEquals(0, aStar0.getVisitedNodes());
      
      WeightApproximator weightApproximator0 = mock(WeightApproximator.class, new ViolatedAssumptionAnswer());
      AStar aStar1 = aStar0.setApproximation(weightApproximator0);
      assertNotNull(aStar1);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      
      Graph graph1 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph1).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph1).getNodeAccess();
      doReturn(0, 0, 0).when(graph1).getNodes();
      Weighting weighting1 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting1).hasTurnCosts();
      TraversalMode traversalMode1 = TraversalMode.EDGE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph1, weighting1, traversalMode1);
      assertNotNull(dijkstraOneToMany0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      
      dijkstraOneToMany0.setMaxVisitedNodes(0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertSame(traversalMode1, traversalMode0);
      
      dijkstraOneToMany0.setWeightLimit((-2136.404884962143));
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertSame(traversalMode1, traversalMode0);
      
      DijkstraOneToMany dijkstraOneToMany1 = dijkstraOneToMany0.clear();
      assertNotNull(dijkstraOneToMany1);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertSame(traversalMode1, traversalMode0);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      Graph graph2 = mock(Graph.class, new ViolatedAssumptionAnswer());
      Weighting weighting2 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(weighting2).hasTurnCosts();
      TraversalMode traversalMode2 = TraversalMode.NODE_BASED;
      Dijkstra dijkstra0 = null;
      try {
        dijkstra0 = new Dijkstra(graph2, weighting2, traversalMode2);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Weightings supporting turn costs cannot be used with node-based traversal mode
         //
         verifyException("com.graphhopper.routing.AbstractRoutingAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      EdgeExplorer edgeExplorer0 = mock(EdgeExplorer.class, new ViolatedAssumptionAnswer());
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null, (NodeAccess) null, (NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      AStar aStar0 = new AStar(graph0, weighting0, traversalMode0);
      assertNotNull(aStar0);
      assertEquals(0, aStar0.getVisitedNodes());
      
      String string0 = aStar0.getName();
      assertNotNull(string0);
      assertEquals("astar|beeline", string0);
      assertEquals(0, aStar0.getVisitedNodes());
      
      aStar0.setMaxVisitedNodes((-2123));
      assertEquals(0, aStar0.getVisitedNodes());
      
      AStar aStar1 = aStar0.setApproximation((WeightApproximator) null);
      assertNotNull(aStar1);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      
      Path path0 = aStar1.extractPath();
      assertNotNull(path0);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertEquals(0L, path0.getTime());
      assertEquals(1.7976931348623157E308, path0.getWeight(), 0.01);
      assertEquals(0, path0.getEdgeCount());
      assertEquals((-1), path0.getEndNode());
      assertEquals("", path0.getDebugInfo());
      assertFalse(path0.isFound());
      assertEquals(0.0, path0.getDistance(), 0.01);
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      
      Path path1 = aStar1.createEmptyPath();
      assertNotNull(path1);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertFalse(path1.isFound());
      assertEquals(0L, path1.getTime());
      assertEquals(1.7976931348623157E308, path1.getWeight(), 0.01);
      assertEquals(0, path1.getEdgeCount());
      assertEquals("", path1.getDebugInfo());
      assertEquals(0.0, path1.getDistance(), 0.01);
      assertEquals((-1), path1.getEndNode());
      assertFalse(path1.equals((Object)path0));
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      assertNotSame(path1, path0);
      
      Path path2 = aStar1.createEmptyPath();
      assertNotNull(path2);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertFalse(path2.isFound());
      assertEquals("", path2.getDebugInfo());
      assertEquals(1.7976931348623157E308, path2.getWeight(), 0.01);
      assertEquals(0L, path2.getTime());
      assertEquals(0, path2.getEdgeCount());
      assertEquals(0.0, path2.getDistance(), 0.01);
      assertEquals((-1), path2.getEndNode());
      assertFalse(path2.equals((Object)path1));
      assertFalse(path2.equals((Object)path0));
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      assertNotSame(path2, path1);
      assertNotSame(path2, path0);
      
      // Undeclared exception!
      try { 
        aStar1.finished();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.graphhopper.routing.AStar", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Graph graph0 = null;
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = null;
      try {
        dijkstraOneToMany0 = new DijkstraOneToMany((Graph) null, weighting0, traversalMode0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Weightings supporting turn costs cannot be used with node-based traversal mode
         //
         verifyException("com.graphhopper.routing.AbstractRoutingAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      doReturn((String) null).when(weighting0).toString();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      Dijkstra dijkstra0 = new Dijkstra(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstra0);
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals("dijkstra", dijkstra0.getName());
      
      dijkstra0.maxVisitedNodes = (-1);
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals("dijkstra", dijkstra0.getName());
      
      boolean boolean0 = dijkstra0.isMaxVisitedNodesExceeded();
      assertTrue(boolean0);
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals("dijkstra", dijkstra0.getName());
      
      String string0 = dijkstra0.toString();
      assertNotNull(string0);
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals("dijkstra", dijkstra0.getName());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      AStar aStar0 = new AStar(graph0, weighting0, traversalMode0);
      assertNotNull(aStar0);
      assertEquals(0, aStar0.getVisitedNodes());
      
      aStar0.maxVisitedNodes = 1327;
      assertEquals(0, aStar0.getVisitedNodes());
      
      // Undeclared exception!
      try { 
        aStar0.calcPaths((-1), (-1));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.graphhopper.routing.weighting.BeelineWeightApproximator", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0, 0, 0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstraOneToMany0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany0.finished());
      
      int int0 = 2059;
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 2059;
      doubleArray0[1] = (double) 2059;
      doubleArray0[2] = (double) 2059;
      doubleArray0[3] = (double) 2059;
      doubleArray0[4] = (double) 2059;
      doubleArray0[5] = (double) 2059;
      doubleArray0[6] = (double) 2059;
      dijkstraOneToMany0.weights = doubleArray0;
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany0.finished());
      
      // Undeclared exception!
      try { 
        dijkstraOneToMany0.calcPaths(2059, 2059);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2059
         //
         verifyException("com.graphhopper.routing.DijkstraOneToMany", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0, 0, 0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstraOneToMany0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany0.finished());
      
      DijkstraOneToMany dijkstraOneToMany1 = dijkstraOneToMany0.clear();
      assertNotNull(dijkstraOneToMany1);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      String string0 = dijkstraOneToMany1.getMemoryUsageAsString();
      assertNotNull(string0);
      assertEquals("0MB", string0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      int int0 = (-3138);
      dijkstraOneToMany0.close();
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany0.finished());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      
      dijkstraOneToMany1.checkAlreadyRun();
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      int int1 = (-553);
      Path path0 = dijkstraOneToMany1.createEmptyPath();
      assertNotNull(path0);
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertEquals((-1), path0.getEndNode());
      assertEquals(0L, path0.getTime());
      assertFalse(path0.isFound());
      assertEquals(0.0, path0.getDistance(), 0.01);
      assertEquals(1.7976931348623157E308, path0.getWeight(), 0.01);
      assertEquals(0, path0.getEdgeCount());
      assertEquals("", path0.getDebugInfo());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      // Undeclared exception!
      try { 
        dijkstraOneToMany1.checkAlreadyRun();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Create a new instance per call
         //
         verifyException("com.graphhopper.routing.AbstractRoutingAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null, (NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      Dijkstra dijkstra0 = new Dijkstra(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstra0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      
      Path path0 = dijkstra0.extractPath();
      assertNotNull(path0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals("", path0.getDebugInfo());
      assertEquals(1.7976931348623157E308, path0.getWeight(), 0.01);
      assertEquals((-1), path0.getEndNode());
      assertEquals(0.0, path0.getDistance(), 0.01);
      assertEquals(0, path0.getEdgeCount());
      assertEquals(0L, path0.getTime());
      assertFalse(path0.isFound());
      
      int int0 = (-4277);
      List<Path> list0 = dijkstra0.calcPaths(0, 0);
      assertNotNull(list0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(1, dijkstra0.getVisitedNodes());
      assertFalse(list0.isEmpty());
      assertEquals(1, list0.size());
      assertFalse(list0.contains(path0));
      
      // Undeclared exception!
      try { 
        dijkstra0.calcPaths((-4277), (-4277));
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Create a new instance per call
         //
         verifyException("com.graphhopper.routing.AbstractRoutingAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null, (NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      Dijkstra dijkstra0 = new Dijkstra(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstra0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      
      Path path0 = dijkstra0.extractPath();
      assertNotNull(path0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals(0, path0.getEdgeCount());
      assertEquals(0L, path0.getTime());
      assertFalse(path0.isFound());
      assertEquals(0.0, path0.getDistance(), 0.01);
      assertEquals(1.7976931348623157E308, path0.getWeight(), 0.01);
      assertEquals((-1), path0.getEndNode());
      assertEquals("", path0.getDebugInfo());
      
      dijkstra0.checkAlreadyRun();
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      
      Path path1 = dijkstra0.extractPath();
      assertNotNull(path1);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals(0.0, path1.getDistance(), 0.01);
      assertFalse(path1.isFound());
      assertEquals(0L, path1.getTime());
      assertEquals(1.7976931348623157E308, path1.getWeight(), 0.01);
      assertEquals(0, path1.getEdgeCount());
      assertEquals("", path1.getDebugInfo());
      assertEquals((-1), path1.getEndNode());
      assertFalse(path1.equals((Object)path0));
      assertNotSame(path1, path0);
      
      // Undeclared exception!
      try { 
        dijkstra0.calcPath(0, 0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Create a new instance per call
         //
         verifyException("com.graphhopper.routing.AbstractRoutingAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      Dijkstra dijkstra0 = new Dijkstra(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstra0);
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals("dijkstra", dijkstra0.getName());
      
      IntObjectMap<SPTEntry> intObjectMap0 = dijkstra0.fromMap;
      assertNotNull(intObjectMap0);
      assertTrue(intObjectMap0.isEmpty());
      assertEquals(0, intObjectMap0.size());
      
      dijkstra0.fromMap = intObjectMap0;
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals("dijkstra", dijkstra0.getName());
      assertTrue(intObjectMap0.isEmpty());
      assertEquals(0, intObjectMap0.size());
      assertEquals(0, dijkstra0.fromMap.size());
      assertTrue(dijkstra0.fromMap.isEmpty());
      
      int int0 = (-1281);
      Path path0 = dijkstra0.createEmptyPath();
      assertNotNull(path0);
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(1.7976931348623157E308, path0.getWeight(), 0.01);
      assertFalse(path0.isFound());
      assertEquals("", path0.getDebugInfo());
      assertEquals(0, path0.getEdgeCount());
      assertEquals(0L, path0.getTime());
      assertEquals((-1), path0.getEndNode());
      assertEquals(0.0, path0.getDistance(), 0.01);
      
      // Undeclared exception!
      try { 
        dijkstra0.calcPaths((-1756), (-1281));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.graphhopper.routing.Dijkstra", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0, 0, 0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstraOneToMany0);
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      
      EdgeIteratorState edgeIteratorState0 = mock(EdgeIteratorState.class, new ViolatedAssumptionAnswer());
      boolean boolean0 = dijkstraOneToMany0.accept(edgeIteratorState0, (-533));
      assertTrue(boolean0);
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0, 0, 0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstraOneToMany0);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      
      dijkstraOneToMany0.maxVisitedNodes = 0;
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      
      boolean boolean0 = dijkstraOneToMany0.isMaxVisitedNodesExceeded();
      assertFalse(boolean0);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      
      Path path0 = dijkstraOneToMany0.calcPath(Integer.MAX_VALUE, 0);
      assertNotNull(path0);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertFalse(path0.isFound());
      assertEquals(0L, path0.getTime());
      assertEquals(1.7976931348623157E308, path0.getWeight(), 0.01);
      assertEquals(0, path0.getEdgeCount());
      assertEquals("", path0.getDebugInfo());
      assertEquals((-1), path0.getEndNode());
      assertEquals(0.0, path0.getDistance(), 0.01);
      
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 0;
      doubleArray0[2] = (double) 0;
      doubleArray0[3] = (double) 0;
      doubleArray0[4] = (double) 0;
      doubleArray0[5] = (double) 0;
      doubleArray0[6] = (double) 0;
      doubleArray0[7] = (double) 0;
      dijkstraOneToMany0.weights = doubleArray0;
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      
      boolean boolean1 = dijkstraOneToMany0.finished();
      assertTrue(boolean1);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertFalse(boolean1 == boolean0);
      
      dijkstraOneToMany0.checkAlreadyRun();
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      AStar aStar0 = new AStar(graph0, weighting0, traversalMode0);
      assertNotNull(aStar0);
      assertEquals(0, aStar0.getVisitedNodes());
      
      aStar0.setMaxVisitedNodes(2851);
      assertEquals(0, aStar0.getVisitedNodes());
      
      int int0 = aStar0.getVisitedNodes();
      assertEquals(0, int0);
      assertEquals(0, aStar0.getVisitedNodes());
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null, (NodeAccess) null, (NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0, 0, 0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstraOneToMany0);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      
      Path path0 = dijkstraOneToMany0.createEmptyPath();
      assertNotNull(path0);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0L, path0.getTime());
      assertFalse(path0.isFound());
      assertEquals("", path0.getDebugInfo());
      assertEquals(1.7976931348623157E308, path0.getWeight(), 0.01);
      assertEquals((-1), path0.getEndNode());
      assertEquals(0.0, path0.getDistance(), 0.01);
      assertEquals(0, path0.getEdgeCount());
      
      DijkstraOneToMany dijkstraOneToMany1 = dijkstraOneToMany0.clear();
      assertNotNull(dijkstraOneToMany1);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      String string0 = dijkstraOneToMany1.getMemoryUsageAsString();
      assertNotNull(string0);
      assertEquals("0MB", string0);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      
      Path path1 = dijkstraOneToMany1.calcPath(79, (-1));
      assertNotNull(path1);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertEquals(0.0, path1.getDistance(), 0.01);
      assertFalse(path1.isFound());
      assertEquals(1.7976931348623157E308, path1.getWeight(), 0.01);
      assertEquals(0L, path1.getTime());
      assertEquals((-1), path1.getEndNode());
      assertEquals(0, path1.getEdgeCount());
      assertEquals("", path1.getDebugInfo());
      assertFalse(path1.equals((Object)path0));
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      assertNotSame(path1, path0);
      
      DijkstraOneToMany dijkstraOneToMany2 = dijkstraOneToMany1.clear();
      assertNotNull(dijkstraOneToMany2);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertTrue(dijkstraOneToMany2.finished());
      assertEquals(0, dijkstraOneToMany2.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany2.getName());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany2);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany2);
      assertSame(dijkstraOneToMany2, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany2, dijkstraOneToMany0);
      
      boolean boolean0 = dijkstraOneToMany1.isMaxVisitedNodesExceeded();
      assertFalse(boolean0);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany2);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany2);
      
      EdgeIteratorState edgeIteratorState0 = mock(EdgeIteratorState.class, new ViolatedAssumptionAnswer());
      doReturn(0).when(edgeIteratorState0).getEdge();
      boolean boolean1 = dijkstraOneToMany1.accept(edgeIteratorState0, 20);
      assertTrue(boolean1);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertEquals(0, dijkstraOneToMany1.getVisitedNodes());
      assertTrue(dijkstraOneToMany1.finished());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany1.getName());
      assertFalse(boolean1 == boolean0);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany2);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany0);
      assertSame(dijkstraOneToMany1, dijkstraOneToMany2);
      
      String string1 = dijkstraOneToMany0.getName();
      assertNotNull(string1);
      assertEquals("dijkstra_one_to_many", string1);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertFalse(string1.equals((Object)string0));
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany2);
      
      Graph graph1 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph1).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null).when(graph1).getNodeAccess();
      doReturn(0).when(graph1).getNodes();
      Weighting weighting1 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting1).hasTurnCosts();
      TraversalMode traversalMode1 = TraversalMode.EDGE_BASED;
      Dijkstra dijkstra0 = new Dijkstra(graph1, weighting1, traversalMode1);
      assertNotNull(dijkstra0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      
      List<Path> list0 = dijkstra0.calcPaths((-1), (-1));
      assertNotNull(list0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(1, dijkstra0.getVisitedNodes());
      assertEquals(1, list0.size());
      assertFalse(list0.isEmpty());
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      assertNotSame(traversalMode1, traversalMode0);
      assertFalse(list0.contains(path0));
      
      boolean boolean2 = dijkstra0.finished();
      assertTrue(boolean2);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(1, dijkstra0.getVisitedNodes());
      assertFalse(boolean2 == boolean0);
      assertTrue(boolean2 == boolean1);
      assertFalse(traversalMode1.equals((Object)traversalMode0));
      assertNotSame(traversalMode1, traversalMode0);
      
      Path path2 = dijkstraOneToMany0.calcPath(20, 20);
      assertNotNull(path2);
      assertEquals(0.0, path2.getDistance(), 0.01);
      assertEquals(1.7976931348623157E308, path2.getWeight(), 0.01);
      assertEquals(0L, path2.getTime());
      assertFalse(path2.isFound());
      assertEquals((-1), path2.getEndNode());
      assertEquals(0, path2.getEdgeCount());
      assertEquals("", path2.getDebugInfo());
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertFalse(traversalMode0.equals((Object)traversalMode1));
      assertFalse(path2.equals((Object)path1));
      assertFalse(path2.equals((Object)path0));
      assertNotSame(traversalMode0, traversalMode1);
      assertNotSame(path2, path1);
      assertNotSame(path2, path0);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany2);
      
      boolean boolean3 = dijkstraOneToMany0.finished();
      assertTrue(boolean3);
      assertEquals(0, dijkstraOneToMany0.getVisitedNodes());
      assertEquals("dijkstra_one_to_many", dijkstraOneToMany0.getName());
      assertTrue(dijkstraOneToMany0.finished());
      assertFalse(traversalMode0.equals((Object)traversalMode1));
      assertFalse(boolean3 == boolean0);
      assertTrue(boolean3 == boolean2);
      assertTrue(boolean3 == boolean1);
      assertNotSame(traversalMode0, traversalMode1);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany1);
      assertSame(dijkstraOneToMany0, dijkstraOneToMany2);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = null;
      try {
        dijkstraOneToMany0 = new DijkstraOneToMany((Graph) null, (Weighting) null, traversalMode0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.graphhopper.routing.AbstractRoutingAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      doReturn((String) null).when(weighting0).toString();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      Dijkstra dijkstra0 = new Dijkstra(graph0, weighting0, traversalMode0);
      assertNotNull(dijkstra0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      
      boolean boolean0 = dijkstra0.isMaxVisitedNodesExceeded();
      assertFalse(boolean0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      
      String string0 = dijkstra0.toString();
      assertNotNull(string0);
      assertEquals("dijkstra", dijkstra0.getName());
      assertEquals(0, dijkstra0.getVisitedNodes());
      
      int int0 = (-946);
      // Undeclared exception!
      try { 
        dijkstra0.calcPath(227, (-946));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.graphhopper.routing.Dijkstra", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      AStar aStar0 = new AStar(graph0, weighting0, traversalMode0);
      assertNotNull(aStar0);
      assertEquals(0, aStar0.getVisitedNodes());
      
      WeightApproximator weightApproximator0 = mock(WeightApproximator.class, new ViolatedAssumptionAnswer());
      AStar aStar1 = aStar0.setApproximation(weightApproximator0);
      assertNotNull(aStar1);
      assertEquals(0, aStar0.getVisitedNodes());
      assertEquals(0, aStar1.getVisitedNodes());
      assertSame(aStar0, aStar1);
      assertSame(aStar1, aStar0);
      
      Graph graph1 = mock(Graph.class, new ViolatedAssumptionAnswer());
      Weighting weighting1 = mock(Weighting.class, new ViolatedAssumptionAnswer());
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null, (NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0, 0, 0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph0, weighting0, traversalMode0);
      dijkstraOneToMany0.getMemoryUsageAsString();
      DijkstraOneToMany dijkstraOneToMany1 = dijkstraOneToMany0.clear();
      dijkstraOneToMany1.createEmptyPath();
      Graph graph1 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph1).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph1).getNodeAccess();
      doReturn(0).when(graph1).getNodes();
      Weighting weighting1 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting1).hasTurnCosts();
      Dijkstra dijkstra0 = new Dijkstra(graph1, weighting1, traversalMode0);
      dijkstra0.maxVisitedNodes = 0;
      dijkstra0.checkAlreadyRun();
      dijkstra0.runAlgo();
      Graph graph2 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph2).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph2).getNodeAccess();
      doReturn(0).when(graph2).getNodes();
      Weighting weighting2 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting2).hasTurnCosts();
      AStar aStar0 = new AStar(graph2, weighting2, traversalMode0);
      WeightApproximator weightApproximator0 = mock(WeightApproximator.class, new ViolatedAssumptionAnswer());
      AStar aStar1 = aStar0.setApproximation(weightApproximator0);
      // Undeclared exception!
      try { 
        aStar1.finished();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.graphhopper.routing.AStar", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      EdgeExplorer edgeExplorer0 = mock(EdgeExplorer.class, new ViolatedAssumptionAnswer());
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      Graph graph1 = mock(Graph.class, new ViolatedAssumptionAnswer());
      Weighting weighting1 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(weighting1).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      Dijkstra dijkstra0 = null;
      try {
        dijkstra0 = new Dijkstra(graph1, weighting1, traversalMode0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Weightings supporting turn costs cannot be used with node-based traversal mode
         //
         verifyException("com.graphhopper.routing.AbstractRoutingAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      Graph graph1 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph1).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph1).getNodeAccess();
      doReturn(0, 0, 0).when(graph1).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.EDGE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph1, weighting0, traversalMode0);
      dijkstraOneToMany0.checkAlreadyRun();
      int int0 = 482;
      dijkstraOneToMany0.findEndNode(482, 482);
      dijkstraOneToMany0.setMaxVisitedNodes(0);
      // Undeclared exception!
      try { 
        dijkstraOneToMany0.checkAlreadyRun();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Create a new instance per call
         //
         verifyException("com.graphhopper.routing.AbstractRoutingAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Graph graph0 = mock(Graph.class, new ViolatedAssumptionAnswer());
      doReturn((EdgeExplorer) null).when(graph0).createEdgeExplorer();
      doReturn((NodeAccess) null).when(graph0).getNodeAccess();
      doReturn(0, 0, 0).when(graph0).getNodes();
      Weighting weighting0 = mock(Weighting.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(weighting0).hasTurnCosts();
      TraversalMode traversalMode0 = TraversalMode.NODE_BASED;
      DijkstraOneToMany dijkstraOneToMany0 = new DijkstraOneToMany(graph0, weighting0, traversalMode0);
      DijkstraOneToMany dijkstraOneToMany1 = dijkstraOneToMany0.clear();
      dijkstraOneToMany1.findEndNode(1, 1);
      EdgeIteratorState edgeIteratorState0 = mock(EdgeIteratorState.class, new ViolatedAssumptionAnswer());
      doReturn(0).when(edgeIteratorState0).getEdge();
      dijkstraOneToMany1.accept(edgeIteratorState0, 0);
      // Undeclared exception!
      try { 
        dijkstraOneToMany1.getWeight(16);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 16
         //
         verifyException("com.graphhopper.routing.DijkstraOneToMany", e);
      }
  }
}
